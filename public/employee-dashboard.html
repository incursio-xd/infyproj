<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Employee Dashboard - Enhanced</title>
    <script src="https://kit.fontawesome.com/64d58efce2.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .workflow-status {
            position: absolute;
            top: 50px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 35;
            display: none;
        }

        .workflow-status.workflow-active {
            display: block;
            background: rgba(76, 175, 80, 0.9);
        }

        .workflow-status.workflow-blocked {
            display: block;
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }

        .drawing-mode {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            z-index: 30;
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0% {
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            }

            100% {
                box-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
            }
        }

        .video-controls-blocked {
            position: relative;
        }

        .video-controls-blocked::after {
            content: "Controls Blocked - Drawing Mode";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 193, 7, 0.95);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 40;
            pointer-events: none;
            white-space: nowrap;
        }

        .video-preview-controls.blocked {
            pointer-events: none;
            opacity: 0.5;
            position: relative;
        }

        .video-preview-controls {
            transition: opacity 0.3s ease, pointer-events 0s linear 0.3s;
        }

        .video-preview-controls:not(.blocked) {
            transition: opacity 0.3s ease, pointer-events 0s linear 0s;
        }

        .status-badge {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 15px;
            font-weight: 600;
            font-size: 0.8rem;
            text-align: center;
            min-width: 80px;
        }

        .status-badge.drawing {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }

        .status-badge.processing {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        .status-badge.blocked {
            background: rgba(244, 67, 54, 0.9);
            color: white;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            min-height: 100vh;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 1rem 2rem;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 600;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logout-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .dashboard-container {
            display: flex;
            height: calc(100vh - 80px);
        }

        .employee-details {
            width: 50%;
            padding: 2rem;
            color: white;
            overflow-y: auto;
        }

        .profile-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 2rem;
        }

        .profile-card h2 {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .profile-info {
            display: grid;
            gap: 1rem;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-item:last-child {
            border-bottom: none;
        }

        .info-label {
            font-weight: 600;
            opacity: 0.8;
        }

        .info-value {
            font-weight: 500;
            text-align: right;
        }

        .camera-access {
            width: 50%;
            padding: 2rem;
            color: white;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .camera-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .camera-buttons {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .camera-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: relative;
        }

        .camera-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .camera-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .processing-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            background: #4CAF50;
            border-radius: 50%;
            animation: pulse 2s infinite;
            display: none;
        }

        .processing-indicator.active {
            display: block;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }

            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
            }

            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }

        .camera-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
        }

        .camera-modal-content {
            width: 98%;
            height: 98%;
            margin: 1% auto;
            padding: 1rem;
        }

        .camera-container {
            grid-template-columns: 1fr 320px;
            gap: 1rem;
        }

        .video-controls {
            padding: 0.75rem;
            gap: 0.75rem;
        }

        .sidebar {
            gap: 0.75rem;
            max-height: 100%;
        }

        .control-card {
            padding: 1rem;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-header h3 {
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .close-modal {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .camera-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 1.5rem;
            overflow: hidden;
            min-height: 0;
            /* Important for proper flex behavior */
        }

        .video-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .video-controls {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            color: white;
        }

        .video-container {
            position: relative;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            overflow: hidden;
            flex: 1;
            min-height: 400px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #webcamVideo,
        #recordedVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 15px;
        }

        #drawingCanvas1,
        #drawingCanvas2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
            z-index: 10;
            pointer-events: none;
        }

        #drawingCanvas1.drawing-active,
        #drawingCanvas2.drawing-active {
            cursor: crosshair;
            pointer-events: auto;
            z-index: 50;
        }

        .camera-placeholder {
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            font-size: 1.2rem;
        }

        .video-preview {
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            font-size: 1rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            /* Enable vertical scrolling */
            max-height: calc(100vh - 200px);
            /* Set maximum height */
            padding-right: 8px;
            /* Add padding for scrollbar space */
        }

        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .sidebar {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(255, 255, 255, 0.1);
        }

        .control-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 1.5rem;
            color: white;
            flex-shrink: 0;
            /* Prevent cards from shrinking too much */
            min-height: auto;
            /* Allow natural height */
        }

        .control-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .zone-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .zone-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            justify-content: center;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50, #45a049);
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.3);
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 1rem;
        }

        .upload-area:hover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .upload-area.dragover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }

        .file-input {
            display: none;
        }

        .video-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .video-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .video-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .video-item.selected {
            background: rgba(78, 205, 196, 0.3);
            border: 1px solid #4ecdc4;
        }

        .yolo-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            display: none;
            z-index: 30;
        }

        .yolo-status.active {
            display: block;
            background: rgba(76, 175, 80, 0.9);
        }

        .yolo-status.waiting {
            display: block;
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }

        .video-preview-controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 0.75rem;
            display: none;
            align-items: center;
            gap: 1rem;
            z-index: 35;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
        }

        .video-preview-controls.visible {
            display: flex !important;
        }

        .video-preview-controls.hidden {
            display: none !important;
        }

        .video-time {
            color: white;
            font-size: 0.9rem;
            min-width: 120px;
            text-align: center;
            font-weight: 500;
        }

        .video-scrubber {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: height 0.2s ease;
        }

        .video-scrubber:hover {
            height: 12px;
        }

        .video-progress {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .play-pause-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-pause-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 80px;
        }

        .volume-icon {
            color: white;
            cursor: pointer;
            font-size: 1rem;
            transition: color 0.3s ease;
        }

        .volume-icon:hover {
            color: #4ecdc4;
        }

        .volume-slider {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .volume-level {
            height: 100%;
            background: #4ecdc4;
            border-radius: 2px;
            width: 50%;
            transition: width 0.1s ease;
        }

        .message {
            position: fixed;
            top: 100px;
            right: 2rem;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            animation: messageSlideIn 0.3s ease;
            z-index: 1001;
            max-width: 400px;
        }

        @keyframes messageSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .message.success {
            background: rgba(76, 175, 80, 0.9);
            color: white;
            border: 1px solid rgba(76, 175, 80, 1);
        }

        .message.error {
            background: rgba(244, 67, 54, 0.9);
            color: white;
            border: 1px solid rgba(244, 67, 54, 1);
        }

        .message.info {
            background: rgba(33, 150, 243, 0.9);
            color: white;
            border: 1px solid rgba(33, 150, 243, 1);
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 1200px) {
            .camera-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }

            .sidebar {
                order: -1;
                /* Move sidebar above video section */
                max-height: 300px;
                /* Reduce height on smaller screens */
                overflow-y: auto;
                margin-bottom: 1rem;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                max-height: 250px;
                gap: 0.8rem;
                padding-right: 4px;
            }

            .control-card {
                padding: 1rem;
            }

            .sidebar::-webkit-scrollbar {
                width: 6px;
            }
        }

        @media (max-width: 768px) {
            .dashboard-container {
                flex-direction: column;
            }

            .employee-details,
            .camera-access {
                width: 100%;
            }

            .camera-modal-content {
                width: 98%;
                height: 98%;
                margin: 1%;
            }

            .camera-buttons {
                flex-direction: column;
            }

            .video-preview-controls {
                flex-wrap: wrap;
                gap: 0.5rem;
                padding: 0.5rem;
            }

            .video-time {
                min-width: 80px;
                font-size: 0.8rem;
            }
        }

        .zone-counts-container {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .total-count-display {
            margin-bottom: 0.5rem;
        }

        #zoneStats1,
        #zoneStats2 {
            max-height: 200px;
            overflow-y: auto;
        }

        #zoneStats1::-webkit-scrollbar,
        #zoneStats2::-webkit-scrollbar {
            width: 6px;
        }

        #zoneStats1::-webkit-scrollbar-track,
        #zoneStats2::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        #zoneStats1::-webkit-scrollbar-thumb,
        #zoneStats2::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        #totalCount1,
        #totalCount2 {
            transition: all 0.3s ease;
        }

        #totalCount1.updated,
        #totalCount2.updated {
            transform: scale(1.1);
            color: #4CAF50 !important;
        }

        #zoneStats1>div,
        #zoneStats2>div {
            transition: all 0.3s ease;
        }

        #zoneStats1>div:hover,
        #zoneStats2>div:hover {
            background: rgba(255, 255, 255, 0.15) !important;
            transform: translateX(5px);
        }

        .analytics-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 15px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            justify-content: center;
            margin-top: 1rem;
        }

        .analytics-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            background: linear-gradient(135deg, #764ba2, #667eea);
        }

        .btn-analytics {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn-analytics:hover:not(:disabled) {
            background: linear-gradient(135deg, #764ba2, #667eea);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
    </style>
</head>

<body>
    <div class="header">
        <h1><i class="fas fa-user"></i> Employee Dashboard</h1>
        <div class="user-info">
            <span id="employee-name">Welcome, Employee!</span>
            <button class="logout-btn" onclick="logout()">
                <i class="fas fa-sign-out-alt"></i> Logout
            </button>
        </div>
    </div>
    <div class="dashboard-container">
        <div class="employee-details">
            <div class="profile-card">
                <h2><i class="fas fa-user-circle"></i> Employee Details</h2>
                <div class="profile-info" id="profile-info">
                </div>
            </div>
        </div>
        <div class="camera-access">
            <div class="camera-card">
                <h2><i class="fas fa-video"></i> Access the Cameras</h2>
                <p style="opacity: 0.8; margin-bottom: 1.5rem;">
                    Select a camera to view live feed or upload video for analysis
                </p>
                <div class="camera-buttons">
                    <button class="camera-btn" onclick="openCamera1()">
                        <i class="fas fa-video"></i> Camera 1 (Live)
                        <div class="processing-indicator" id="camera1Indicator"></div>
                    </button>
                    <button class="camera-btn" onclick="openCamera2()">
                        <i class="fas fa-video"></i> Camera 2 (Recorded)
                        <div class="processing-indicator" id="camera2Indicator"></div>
                    </button>
                </div>
                <a href="/analytics-dashboard.html" target="_blank" class="analytics-btn">
                    <i class="fas fa-chart-line"></i> View Live Analytics Dashboard
                </a>
            </div>
        </div>
    </div>
    <div id="camera1Modal" class="camera-modal">
        <div class="camera-modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-video"></i> Camera 1 - Live Feed</h3>
                <button class="close-modal" onclick="closeCameraModal(1)">&times;</button>
            </div>
            <div class="camera-container">
                <div class="video-section">
                    <div class="video-controls">
                        <button id="startWebcam1" class="btn btn-success">
                            <i class="fas fa-play"></i> Start Camera
                        </button>
                        <button id="stopWebcam1" class="btn btn-danger" disabled>
                            <i class="fas fa-stop"></i> Stop Camera
                        </button>
                        <button id="drawZoneBtn1" class="btn" disabled>
                            <i class="fas fa-draw-polygon"></i> Draw Zone
                        </button>
                        <button id="startProcessing1" class="btn" disabled>
                            <i class="fas fa-brain"></i> Start YOLO
                        </button>
                        <button id="stopProcessing1" class="btn btn-danger" disabled>
                            <i class="fas fa-stop"></i> Stop YOLO
                        </button>
                        <button class="btn btn-analytics" onclick="openAnalyticsDashboard()">
                            <i class="fas fa-chart-area"></i> View Analytics
                        </button>
                    </div>

                    <div class="video-container">
                        <video id="webcamVideo" autoplay muted style="display: none;"></video>
                        <canvas id="drawingCanvas1"></canvas>
                        <div class="camera-placeholder" id="cameraPlaceholder1">
                            <i class="fas fa-video" style="font-size: 3rem; margin-bottom: 1rem;"></i>
                            <p>Click "Start Camera" to begin</p>
                        </div>
                        <div class="drawing-mode" id="drawingMode1" style="display: none;">
                            Drawing Zone - Click to add points, double-click to finish
                        </div>
                        <div class="yolo-status" id="yoloStatus1">
                            <i class="fas fa-brain"></i> YOLO Processing Active
                        </div>
                    </div>
                </div>
            </div>
            <div id="zoneStats1">
            </div>
        </div>
    </div>

    <!-- Camera 2 Modal (Recorded) -->
    <div id="camera2Modal" class="camera-modal">
        <div class="camera-modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-video"></i> Camera 2 - Recorded Video</h3>
                <button class="close-modal" onclick="closeCameraModal(2)">&times;</button>
            </div>

            <div class="camera-container">
                <div class="video-section">
                    <div class="video-controls">
                        <button id="selectVideoBtn2" class="btn">
                            <i class="fas fa-folder-open"></i> Select Video
                        </button>
                        <button id="drawZoneBtn2" class="btn" disabled>
                            <i class="fas fa-draw-polygon"></i> Draw Zone
                        </button>
                        <button id="startProcessing2" class="btn" disabled>
                            <i class="fas fa-brain"></i> Start YOLO
                        </button>
                        <button id="stopProcessing2" class="btn btn-danger" disabled>
                            <i class="fas fa-stop"></i> Stop YOLO
                        </button>
                        <button class="btn btn-analytics" onclick="openAnalyticsDashboard()">
                            <i class="fas fa-chart-area"></i> View Analytics
                        </button>
                    </div>

                    <div class="video-container">
                        <!-- Recorded video element -->
                        <video id="recordedVideo" style="display: none;"></video>
                        <canvas id="drawingCanvas2"></canvas>

                        <!-- Placeholder shown before video load -->
                        <div class="camera-placeholder" id="cameraPlaceholder2">
                            <i class="fas fa-upload" style="font-size: 3rem; margin-bottom: 1rem;"></i>
                            <p>Upload or select a video file</p>
                        </div>

                        <!-- Preview shown after video load -->
                        <div class="video-preview" id="videoPreview2" style="display: none;">
                            <i class="fas fa-play-circle" style="font-size: 4rem; margin-bottom: 1rem;"></i>
                            <p>Video loaded - Ready for zone drawing</p>
                            <small>Use the controls below to navigate</small>
                        </div>

                        <!-- Drawing mode indicator -->
                        <div class="drawing-mode" id="drawingMode2" style="display: none;">
                            Drawing Zone - Click to add points, double-click to finish
                        </div>

                        <!-- YOLO processing status -->
                        <div class="yolo-status" id="yoloStatus2">
                            <i class="fas fa-brain"></i> YOLO Processing Active
                        </div>

                        <!-- Custom Video Controls -->
                        <div class="video-preview-controls" id="videoControls2">
                            <button class="play-pause-btn" id="playPauseBtn2">
                                <i class="fas fa-play"></i>
                            </button>
                            <div class="video-time" id="videoTime2">00:00 / 00:00</div>
                            <div class="video-scrubber" id="videoScrubber2">
                                <div class="video-progress" id="videoProgress2"></div>
                            </div>
                            <div class="volume-control">
                                <i class="fas fa-volume-up volume-icon" id="volumeIcon2"></i>
                                <div class="volume-slider" id="volumeSlider2">
                                    <div class="volume-level" id="volumeLevel2"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sidebar -->
                <div class="sidebar">
                    <div class="control-card upload-section">
                        <div class="control-title">
                            <i class="fas fa-upload"></i> Video Upload
                        </div>
                        <div class="upload-area" onclick="document.getElementById('videoFileInput').click()">
                            <i class="fas fa-cloud-upload-alt" style="font-size: 2rem; margin-bottom: 0.5rem;"></i>
                            <p>Click to upload video file</p>
                            <small>Supports MP4, AVI, MOV, etc. (Max 500MB)</small>
                        </div>
                        <input type="file" id="videoFileInput" class="file-input" accept="video/*">
                        <div class="video-list" id="videoList2"></div>
                    </div>

                    <div class="control-card">
                        <div class="control-title">
                            <i class="fas fa-draw-polygon"></i> Zone Controls
                        </div>
                        <div class="input-group" id="zoneNameGroup2" style="display: none;">
                            <label for="zoneNameInput2">Zone Name:</label>
                            <input type="text" id="zoneNameInput2" placeholder="Enter zone name">

                            <label for="zoneCapacityInput2" style="margin-top: 1rem;">Zone Capacity Limit:</label>
                            <input type="number" id="zoneCapacityInput2" placeholder="Enter maximum capacity" min="1"
                                value="10">

                            <label for="zoneWarningInput2" style="margin-top: 1rem;">Warning Threshold:</label>
                            <input type="number" id="zoneWarningInput2" placeholder="Warning at this count" min="1"
                                value="8">

                            <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                                <button class="btn btn-success btn-small" onclick="saveCurrentZone(2)">
                                    <i class="fas fa-save"></i> Save Zone
                                </button>
                                <button class="btn btn-small" onclick="cancelCurrentZone(2)">
                                    <i class="fas fa-times"></i> Cancel
                                </button>
                            </div>
                        </div>
                        <div id="zoneInstructions2">
                            <p style="opacity: 0.8; font-size: 0.9rem;">
                                1. Start the camera<br>
                                2. Click "Draw Zone"<br>
                                3. Click points to create zone boundary<br>
                                4. Double-click to finish drawing<br>
                                5. Enter zone name and capacity limits<br>
                                6. Save the zone<br>
                                7. Start YOLO processing
                            </p>
                        </div>
                    </div>
                    <div class="control-card">
                        <div class="control-title">
                            <i class="fas fa-users"></i> Live Count
                        </div>
                        <div class="zone-counts-container">
                            <div class="total-count-display">
                                <div
                                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 10px;">
                                    <span style="font-weight: 600; font-size: 1.1rem;">Total People:</span>
                                    <span id="totalCount2"
                                        style="font-size: 1.3rem; font-weight: 700; color: #4ecdc4;">0</span>
                                </div>
                            </div>
                            <div id="zoneStats2" style="font-size: 0.95rem;">
                                <p style="opacity: 0.7; text-align: center; font-style: italic;">Start YOLO processing
                                    to see live counts</p>
                            </div>
                        </div>
                    </div>
                    <div class="control-card">
                        <div class="control-title">
                            <i class="fas fa-list"></i> Saved Zones
                        </div>
                        <div id="zonesList2">
                            <p style="opacity: 0.7; text-align: center;">No zones created yet</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <script src="/socket.io/socket.io.js"></script>
    <script>
        const API_BASE = 'http://localhost:7000/api';

        let socket = null;
        let currentStream = null;
        let selectedVideoId = null;
        let selectedVideoPath = null;
        let cameras = {
            1: {
                isDrawing: false,
                currentPath: [],
                savedZones: [],
                canvas: null,
                ctx: null,
                video: null,
                processing: false,
                yoloActive: false,
                videoWidth: null,
                videoHeight: null,
                canvasWidth: null,
                canvasHeight: null,
                isReady: false,
                zonesLoaded: false,
                pendingButtonUpdate: false
            },
            2: {
                isDrawing: false,
                currentPath: [],
                savedZones: [],
                canvas: null,
                ctx: null,
                video: null,
                processing: false,
                yoloActive: false,
                uploadedVideos: [],
                videoLoaded: false,
                controlsVisible: false,
                videoWidth: null,
                videoHeight: null,
                canvasWidth: null,
                canvasHeight: null,
                isReady: false,
                zonesLoaded: false,
                pendingButtonUpdate: false
            }
        };
        const zoneColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
            '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'
        ];
        function checkCameraReadiness(cameraId) {
            const camera = cameras[cameraId];

            let videoReady = false;
            let hasValidDimensions = false;

            if (cameraId === 1) {
                videoReady = camera.video &&
                    camera.video.srcObject &&
                    camera.video.readyState >= 2;
                hasValidDimensions = camera.videoWidth > 0 && camera.videoHeight > 0;
            } else {
                videoReady = camera.video &&
                    camera.video.src &&
                    camera.videoLoaded &&
                    camera.video.readyState >= 2;
                hasValidDimensions = camera.videoWidth > 0 && camera.videoHeight > 0;
            }

            const hasZones = camera.savedZones && camera.savedZones.length > 0;
            const zonesLoaded = camera.zonesLoaded === true;
            const canvasReady = camera.canvasWidth > 0 && camera.canvasHeight > 0;

            const isFullyReady = videoReady && hasValidDimensions && zonesLoaded && canvasReady;

            console.log(`Camera ${cameraId} readiness check:`, {
                videoReady,
                hasValidDimensions: hasValidDimensions,
                hasZones,
                zonesLoaded,
                canvasReady,
                isFullyReady,
                videoReadyState: camera.video ? camera.video.readyState : 'no video',
                videoDimensions: `${camera.videoWidth}x${camera.videoHeight}`
            });

            return {
                isFullyReady,
                videoReady,
                hasZones,
                zonesLoaded,
                canvasReady,
                hasValidDimensions
            };
        }


        function updateCameraState(cameraId, stateUpdates = {}) {
            console.log(`Updating camera ${cameraId} state:`, stateUpdates);


            Object.keys(stateUpdates).forEach(key => {
                cameras[cameraId][key] = stateUpdates[key];
            });


            const readiness = checkCameraReadiness(cameraId);
            cameras[cameraId].isReady = readiness.isFullyReady;


            updateProcessingButtonsWithState(cameraId, readiness);


            updateDrawButtonState(cameraId, readiness);

            console.log(`Camera ${cameraId} state updated. Ready: ${cameras[cameraId].isReady}`);
        }


        function updateDrawButtonState(cameraId, readiness) {
            const drawBtn = document.getElementById(`drawZoneBtn${cameraId}`);

            if (!drawBtn) return;

            const canDraw = readiness.videoReady && readiness.hasValidDimensions && readiness.canvasReady;

            if (cameras[cameraId].isDrawing) {

                drawBtn.disabled = false;
                drawBtn.innerHTML = '<i class="fas fa-times"></i> Cancel Drawing';
                drawBtn.classList.add('btn-danger');
            } else {
                drawBtn.disabled = !canDraw;
                drawBtn.innerHTML = '<i class="fas fa-draw-polygon"></i> Draw Zone';
                drawBtn.classList.remove('btn-danger');

                if (canDraw) {
                    drawBtn.title = 'Click to start drawing a zone';
                } else if (!readiness.videoReady) {
                    drawBtn.title = `${cameraId === 1 ? 'Start camera first' : 'Load video first'}`;
                } else {
                    drawBtn.title = 'Video not ready for drawing';
                }
            }
        }
        window.addEventListener('load', () => {
            console.log('Dashboard loading with enhanced state management...');
            checkAuth();
            loadUserInfo();
            loadProfile();
            initializeSocket();
            setupEventListeners();
            loadUploadedVideos();

            setTimeout(() => {
                setupVideoControls();


                [1, 2].forEach(cameraId => {
                    updateCameraState(cameraId, {
                        zonesLoaded: false,
                        isReady: false
                    });
                });

            }, 500);

            setTimeout(() => {
                checkYOLORequirements();
            }, 2000);
        });

        function openAnalyticsDashboard() {
            const analyticsWindow = window.open('/analytics-dashboard.html', 'AnalyticsDashboard', 'width=1400,height=900,scrollbars=yes,resizable=yes');

            if (analyticsWindow) {
                analyticsWindow.focus();
                showMessage('Opening Live Analytics Dashboard...', 'info');
            } else {
                showMessage('Please allow popups or manually navigate to the analytics dashboard', 'error');
                setTimeout(() => {
                    window.open('/analytics-dashboard.html', '_blank');
                }, 1000);
            }
        }

        function checkAuth() {
            const token = localStorage.getItem('token');
            const user = JSON.parse(localStorage.getItem('user') || '{}');

            if (!token || user.role !== 'employee') {
                window.location.href = '/';
                return false;
            }
            return true;
        }


        let videoControlWorkflow = {
            isDrawingZoneBlocked: false,
            wasVideoPlayingBeforeDrawing: false,
            autoResumeAfterDrawing: false
        };


        function handleCamera2DrawingWorkflow(isEnteringDrawingMode) {
            const video = cameras[2].video;

            if (isEnteringDrawingMode) {

                console.log('Entering drawing mode - implementing video control workflow');


                videoControlWorkflow.isDrawingZoneBlocked = true;
                blockDrawingZoneVideoControl();


                if (video && !video.paused) {
                    videoControlWorkflow.wasVideoPlayingBeforeDrawing = true;

                    showMessage('Video playing in draw zone mode. Video controls are temporarily blocked.', 'info');
                } else if (video && video.paused) {

                    videoControlWorkflow.wasVideoPlayingBeforeDrawing = false;
                    playVideoForDrawing();
                }


                showVideoControls(false);

            } else {

                console.log('Exiting drawing mode - restoring video control access');


                videoControlWorkflow.isDrawingZoneBlocked = false;
                unblockDrawingZoneVideoControl();


                if (cameras[2].videoLoaded) {
                    setTimeout(() => showVideoControls(true), 100);
                }


                if (videoControlWorkflow.wasVideoPlayingBeforeDrawing) {

                    if (video && video.paused) {
                        video.play().catch(e => console.error('Error resuming video:', e));
                    }
                } else {

                    if (video && !video.paused) {
                        video.pause();
                    }
                }

                showMessage('Drawing mode exited. Video controls restored.', 'success');
            }
        }


        function blockDrawingZoneVideoControl() {
            const videoControls = document.getElementById('videoControls2');
            const playPauseBtn = document.getElementById('playPauseBtn2');
            const videoScrubber = document.getElementById('videoScrubber2');

            if (videoControls) {
                videoControls.style.pointerEvents = 'none';
                videoControls.style.opacity = '0.5';


                const blockedIndicator = document.createElement('div');
                blockedIndicator.id = 'drawingModeBlocker';
                blockedIndicator.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 193, 7, 0.9);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            z-index: 40;
            pointer-events: none;
        `;
                blockedIndicator.textContent = 'Controls blocked - Drawing mode active';

                const videoContainer = document.querySelector('#camera2Modal .video-container');
                if (videoContainer) {
                    videoContainer.appendChild(blockedIndicator);
                }
            }
        }


        function unblockDrawingZoneVideoControl() {
            const videoControls = document.getElementById('videoControls2');
            const blockedIndicator = document.getElementById('drawingModeBlocker');

            if (videoControls) {
                videoControls.style.pointerEvents = 'auto';
                videoControls.style.opacity = '1';
            }

            if (blockedIndicator) {
                blockedIndicator.remove();
            }
        }

        function playVideoForDrawing() {
            const video = cameras[2].video;

            if (video && video.paused) {
                video.play().then(() => {
                    console.log('Video playing for drawing zone mode');
                    showMessage('Video auto-started for drawing zone mode', 'info');
                }).catch(e => {
                    console.error('Error playing video for drawing:', e);
                    showMessage('Could not auto-play video for drawing mode', 'error');
                });
            }
        }


        function handleVideoClick(e) {
            if (!cameras[2].isDrawing) {

                e.preventDefault();
                e.stopPropagation();

                const video = cameras[2].video;
                showVideoControls(true);

                if (video.paused) {
                    video.play().then(() => {
                        document.getElementById('playPauseBtn2').innerHTML = '<i class="fas fa-pause"></i>';
                    }).catch(console.error);
                } else {
                    video.pause();
                    document.getElementById('playPauseBtn2').innerHTML = '<i class="fas fa-play"></i>';
                }
            } else {

                console.log('Video click ignored - drawing mode active');
            }
        }


        function finishDrawing(event, cameraId) {
            console.log(`finishDrawing called for camera ${cameraId}, drawing state: ${cameras[cameraId].isDrawing}, points: ${cameras[cameraId].currentPath.length}`);

            if (!cameras[cameraId].isDrawing) {
                console.log(`Not in drawing mode for camera ${cameraId}`);
                return;
            }

            if (cameras[cameraId].currentPath.length < 3) {
                console.log(`Not enough points (${cameras[cameraId].currentPath.length}) for camera ${cameraId}`);
                showMessage('Zone must have at least 3 points', 'error');
                return;
            }

            event.preventDefault();
            event.stopPropagation();

            console.log(`Finishing drawing for camera ${cameraId} with ${cameras[cameraId].currentPath.length} points`);

            document.getElementById(`zoneNameGroup${cameraId}`).style.display = 'block';
            document.getElementById(`zoneInstructions${cameraId}`).style.display = 'none';
            document.getElementById(`zoneNameInput${cameraId}`).focus();


            cameras[cameraId].isDrawing = false;
            updateDrawingMode(cameraId);


            if (cameraId === 2) {
                handleCamera2DrawingWorkflow(false);
            }
        }


        function cancelCurrentZone(cameraId) {
            cameras[cameraId].currentPath = [];
            document.getElementById(`zoneNameInput${cameraId}`).value = '';
            document.getElementById(`zoneNameGroup${cameraId}`).style.display = 'none';
            document.getElementById(`zoneInstructions${cameraId}`).style.display = 'block';


            if (cameraId === 2) {
                if (videoControlWorkflow.isDrawingZoneBlocked) {
                    unblockDrawingZoneVideoControl();
                    videoControlWorkflow.isDrawingZoneBlocked = false;
                }

                if (cameras[2].videoLoaded) {
                    setTimeout(() => showVideoControls(true), 100);
                }
            }

            redrawCanvas(cameraId);
        }


        function setupVideoControlsEnhanced() {
            console.log("Setting up enhanced video controls for camera 2");

            const video = document.getElementById('recordedVideo');
            if (video) {

                video.addEventListener('click', handleVideoClick);


                cameras[2].video = video;

                const canvas = document.getElementById('drawingCanvas2');
                if (canvas) {
                    cameras[2].canvas = canvas;
                    cameras[2].ctx = canvas.getContext('2d');

                    setTimeout(() => updateCanvasSize(2), 50);
                }
            }
        }



        function reportWorkflowStatus() {
            if (videoControlWorkflow.isDrawingZoneBlocked) {
                console.log('Video Control Workflow Status: BLOCKED (Drawing mode active)');
                return 'blocked';
            } else {
                console.log('Video Control Workflow Status: ACTIVE (Normal mode)');
                return 'active';
            }
        }


        document.addEventListener('DOMContentLoaded', () => {

            setTimeout(() => {
                setupVideoControlsEnhanced();
                console.log('Video control workflow initialized');
            }, 1000);
        });


        setInterval(() => {
            if (cameras[2] && cameras[2].isDrawing !== undefined) {
                const status = reportWorkflowStatus();


                const workflowIndicator = document.getElementById('workflowStatus');
                if (workflowIndicator) {
                    workflowIndicator.textContent = `Workflow: ${status.toUpperCase()}`;
                    workflowIndicator.className = status === 'blocked' ? 'workflow-blocked' : 'workflow-active';
                }
            }
        }, 2000);

        function loadUserInfo() {
            const user = JSON.parse(localStorage.getItem('user') || '{}');
            document.getElementById('employee-name').textContent =
                `Welcome, ${user.full_name || user.username || 'Employee'}!`;
        }

        async function loadProfile() {
            try {
                const token = localStorage.getItem('token');
                if (!token) return;

                const response = await fetch(`${API_BASE}/profile`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const profile = await response.json();
                    displayProfile(profile);
                } else if (response.status === 401) {
                    showMessage('Session expired. Please login again.', 'error');
                    setTimeout(() => {
                        localStorage.removeItem('token');
                        localStorage.removeItem('user');
                        window.location.href = '/';
                    }, 2000);
                }
            } catch (error) {
                console.error('Error loading profile:', error);
            }
        }

        function displayProfile(profile) {
            const profileInfo = document.getElementById('profile-info');
            profileInfo.innerHTML = `
                <div class="info-item">
                    <span class="info-label">Full Name:</span>
                    <span class="info-value">${profile.full_name || 'Not set'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Username:</span>
                    <span class="info-value">${profile.username}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Email:</span>
                    <span class="info-value">${profile.email || 'Not set'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Department:</span>
                    <span class="info-value">${profile.department || 'Not assigned'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Role:</span>
                    <span class="info-value">${profile.role || 'Employee'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Last Login:</span>
                    <span class="info-value">${profile.last_login ? new Date(profile.last_login).toLocaleDateString() : 'Never'}</span>
                </div>
            `;
        }


        function initializeSocket() {
            socket = io();

            socket.on('connect', () => {
                console.log('Connected to server');
                checkYOLORequirements();
                monitorYOLOProcesses();
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
            });


            socket.on('live_camera_data', (data) => {
                console.log('Received live camera data:', data);
                updateLiveStats(data);
            });


            socket.on('camera_stats_update', (data) => {
                console.log('Received camera stats update:', data);
                if (data.cameraId === 1) {
                    updateCamera1Stats({
                        camera_id: 1,
                        total_count: data.totalCount,
                        zone_counts: data.zoneCounts,
                        fps: data.fps
                    });
                } else if (data.cameraId === 2) {
                    updateCamera2Stats({
                        camera_id: 2,
                        total_count: data.totalCount,
                        zone_counts: data.zoneCounts,
                        fps: data.fps
                    });
                }
            });

            socket.on('camera_processing_status', (status) => {
                handleProcessingStatus(status);
            });

            socket.on('zones_updated', (data) => {
                console.log('Zones updated:', data);
                loadSavedZones(data.camera_id);
            });

            socket.on('yolo_process_status', (status) => {
                console.log('YOLO process status:', status);
                updateCameraYOLOStatus(status.cameraId, status);

                if (status.status === 'running') {
                    showMessage(`YOLO processing is now active for Camera ${status.cameraId}`, 'success');
                } else if (status.status === 'error') {
                    showMessage(`YOLO processing error on Camera ${status.cameraId}: ${status.message}`, 'error');
                } else if (status.status === 'stopped') {
                    showMessage(`YOLO processing stopped for Camera ${status.cameraId}`, 'info');
                }
            });


            socket.onAny((eventName, ...args) => {
                console.log(`Socket event received: ${eventName}`, args);
            });
        }



        function setupEventListeners() {
            console.log('Setting up event listeners...');

            setupCameraEventListeners(1);
            setupCameraEventListeners(2);

            document.getElementById('videoFileInput').addEventListener('change', handleVideoUpload);

            const uploadArea = document.querySelector('.upload-area');
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleVideoFile(files[0]);
                }
            });
        }

        function setupCameraEventListeners(cameraId) {
            console.log(`Setting up camera ${cameraId} event listeners...`);

            const canvas = document.getElementById(`drawingCanvas${cameraId}`);
            if (!canvas) {
                console.error(`Canvas not found for camera ${cameraId}`);
                return;
            }

            const ctx = canvas.getContext('2d');
            cameras[cameraId].canvas = canvas;
            cameras[cameraId].ctx = ctx;

            if (cameraId === 1) {
                document.getElementById('startWebcam1').addEventListener('click', () => {
                    console.log('Start webcam clicked');
                    startWebcam(1);
                });
                document.getElementById('stopWebcam1').addEventListener('click', () => stopWebcam(1));
            } else {
                document.getElementById('selectVideoBtn2').addEventListener('click', () => {
                    document.getElementById('videoFileInput').click();
                });
            }

            const drawBtn = document.getElementById(`drawZoneBtn${cameraId}`);
            if (drawBtn) {
                drawBtn.addEventListener('click', () => {
                    console.log(`Draw zone button clicked for camera ${cameraId}`);
                    toggleDrawMode(cameraId);
                });
            }

            document.getElementById(`startProcessing${cameraId}`).addEventListener('click', () => startYOLOProcessing(cameraId));
            document.getElementById(`stopProcessing${cameraId}`).addEventListener('click', () => stopYOLOProcessing(cameraId));

            canvas.addEventListener('click', (e) => {
                console.log(`Canvas ${cameraId} clicked, drawing mode:`, cameras[cameraId].isDrawing);
                handleCanvasClick(e, cameraId);
            });

            canvas.addEventListener('dblclick', (e) => {
                console.log(`Canvas ${cameraId} double-clicked`);
                if (cameras[cameraId].isDrawing && cameras[cameraId].currentPath.length >= 3) {
                    finishDrawing(e, cameraId);
                }
            });



            setTimeout(() => updateCanvasSize(cameraId), 200);
            window.addEventListener('resize', () => {
                setTimeout(() => updateCanvasSize(cameraId), 100);
            });
        }


        function openCamera1() {
            console.log('Opening Camera 1 modal...');
            document.getElementById('camera1Modal').style.display = 'block';
            document.body.style.overflow = 'hidden';

            setTimeout(() => updateCanvasSize(1), 100);
            setTimeout(() => updateCanvasSize(1), 300);
            setTimeout(() => updateCanvasSize(1), 500);
        }

        function openCamera2() {
            console.log('Opening Camera 2 modal...');
            document.getElementById('camera2Modal').style.display = 'block';
            document.body.style.overflow = 'hidden';

            setTimeout(() => updateCanvasSize(2), 100);
            setTimeout(() => updateCanvasSize(2), 300);
            setTimeout(() => updateCanvasSize(2), 500);

            setTimeout(() => {
                const video = document.getElementById('recordedVideo');
                if (video && video.src && cameras[2].videoLoaded) {
                    showVideoControls(true);
                }
            }, 200);
        }

        function closeCameraModal(cameraId) {
            console.log(`Closing camera ${cameraId} modal`);
            document.getElementById(`camera${cameraId}Modal`).style.display = 'none';
            document.body.style.overflow = 'auto';

            if (cameras[cameraId].isDrawing) {
                cameras[cameraId].isDrawing = false;
                cameras[cameraId].currentPath = [];
                updateDrawingMode(cameraId);
            }

            if (cameraId === 1) {
                stopWebcam(1);
            } else if (cameraId === 2) {
                const video = cameras[2].video;
                if (video && !video.paused) {
                    video.pause();
                }
                showVideoControls(false);
            }

            stopYOLOProcessing(cameraId);
        }


        function updateCanvasSize(cameraId) {
            const canvas = cameras[cameraId].canvas;
            if (!canvas) {
                console.error(`Canvas not found for camera ${cameraId}`);
                return;
            }

            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();

            if (rect.width <= 0 || rect.height <= 0) {
                setTimeout(() => updateCanvasSize(cameraId), 100);
                return;
            }


            canvas.width = rect.width;
            canvas.height = rect.height;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';


            updateCameraState(cameraId, {
                canvasWidth: rect.width,
                canvasHeight: rect.height
            });

            console.log(`Canvas ${cameraId} resized to: ${rect.width}x${rect.height}`);

            redrawCanvas(cameraId);
        }

        function toggleDrawMode(cameraId) {
            console.log(`Toggling draw mode for camera ${cameraId}`);
            if (!cameras[cameraId].isDrawing) {
                if (!cameras[cameraId].videoWidth || !cameras[cameraId].videoHeight) {
                    showMessage('Please load a video first before drawing zones', 'error');
                    return;
                }
                if (!cameras[cameraId].canvasWidth || !cameras[cameraId].canvasHeight) {
                    showMessage('Canvas not properly initialized', 'error');
                    return;
                }
            }
            cameras[cameraId].isDrawing = !cameras[cameraId].isDrawing;
            cameras[cameraId].currentPath = [];

            updateDrawingMode(cameraId);
            redrawCanvas(cameraId);

            if (cameraId === 2) {
                if (cameras[cameraId].isDrawing) {
                    showVideoControls(false);
                } else if (cameras[2].videoLoaded) {
                    setTimeout(() => showVideoControls(true), 100);
                }
            }
        }

        function updateDrawingMode(cameraId) {
            const drawingMode = document.getElementById(`drawingMode${cameraId}`);
            const drawBtn = document.getElementById(`drawZoneBtn${cameraId}`);
            const canvas = cameras[cameraId].canvas;

            if (cameras[cameraId].isDrawing) {
                console.log(`Enabling drawing mode for camera ${cameraId}`);
                drawingMode.style.display = 'block';
                drawBtn.innerHTML = '<i class="fas fa-times"></i> Cancel Drawing';
                drawBtn.classList.add('btn-danger');
                canvas.classList.add('drawing-active');
                showMessage(`Drawing mode enabled for Camera ${cameraId}. Click to add points, double-click to finish.`, 'info');
            } else {
                console.log(`Disabling drawing mode for camera ${cameraId}`);
                drawingMode.style.display = 'none';
                drawBtn.innerHTML = '<i class="fas fa-draw-polygon"></i> Draw Zone';
                drawBtn.classList.remove('btn-danger');
                canvas.classList.remove('drawing-active');
            }
        }

        function handleCanvasClick(event, cameraId) {
            if (!cameras[cameraId].isDrawing) {
                console.log(`Canvas click ignored - not in drawing mode for camera ${cameraId}`);
                return;
            }

            if (!cameras[cameraId].videoWidth || !cameras[cameraId].videoHeight) {
                showMessage('Video dimensions not available. Please reload the video.', 'error');
                return;
            }

            event.preventDefault();
            event.stopPropagation();

            const canvas = cameras[cameraId].canvas;
            const rect = canvas.getBoundingClientRect();

            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            const videoX = (canvasX / cameras[cameraId].canvasWidth) * cameras[cameraId].videoWidth;
            const videoY = (canvasY / cameras[cameraId].canvasHeight) * cameras[cameraId].videoHeight;

            console.log(`Canvas click: (${canvasX}, ${canvasY}) -> Video coords: (${videoX}, ${videoY})`);

            cameras[cameraId].currentPath.push({
                x: Math.round(videoX),
                y: Math.round(videoY)
            });

            redrawCanvas(cameraId);

            showMessage(`Point ${cameras[cameraId].currentPath.length} added. Double-click to finish zone.`, 'info');
        }

        function convertVideoToCanvasCoordinates(videoPoints, cameraId) {
            if (!cameras[cameraId].videoWidth || !cameras[cameraId].canvasWidth) {
                return videoPoints;
            }

            return videoPoints.map(point => ({
                x: (point.x / cameras[cameraId].videoWidth) * cameras[cameraId].canvasWidth,
                y: (point.y / cameras[cameraId].videoHeight) * cameras[cameraId].canvasHeight
            }));
        }

        function convertCanvasToVideoCoordinates(canvasPoints, cameraId) {
            if (!cameras[cameraId].videoWidth || !cameras[cameraId].canvasWidth) {
                return canvasPoints;
            }

            return canvasPoints.map(point => ({
                x: (point.x / cameras[cameraId].canvasWidth) * cameras[cameraId].videoWidth,
                y: (point.y / cameras[cameraId].canvasHeight) * cameras[cameraId].videoHeight
            }));
        }

        function redrawCanvas(cameraId) {
            const ctx = cameras[cameraId].ctx;
            const canvas = cameras[cameraId].canvas;
            if (!ctx || !canvas) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);


            cameras[cameraId].savedZones.forEach(zone => {
                if (zone.points && zone.points.length > 0) {

                    let canvasPoints;
                    if (cameras[cameraId].videoWidth && cameras[cameraId].canvasWidth) {

                        canvasPoints = zone.points.map(point => ({
                            x: (point.x / cameras[cameraId].videoWidth) * cameras[cameraId].canvasWidth,
                            y: (point.y / cameras[cameraId].videoHeight) * cameras[cameraId].canvasHeight
                        }));
                    } else {

                        canvasPoints = zone.points;
                    }
                    drawPolygon(ctx, canvasPoints, zone.color, zone.name, false);
                }
            });

            if (cameras[cameraId].currentPath.length > 0) {
                let canvasCurrentPath;
                if (cameras[cameraId].videoWidth && cameras[cameraId].canvasWidth) {
                    canvasCurrentPath = cameras[cameraId].currentPath.map(point => ({
                        x: (point.x / cameras[cameraId].videoWidth) * cameras[cameraId].canvasWidth,
                        y: (point.y / cameras[cameraId].videoHeight) * cameras[cameraId].canvasHeight
                    }));
                } else {
                    canvasCurrentPath = cameras[cameraId].currentPath;
                }
                drawPolygon(ctx, canvasCurrentPath, '#FFFF00', 'Drawing...', true);
            }
        }
        function drawPolygon(ctx, points, color, label, isDrawing = false) {
            if (!points || points.length === 0) return;

            ctx.save();

            ctx.fillStyle = isDrawing ? 'rgba(255, 255, 0, 0.2)' : hexToRgba(color, 0.25);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }

            if (!isDrawing) {
                ctx.closePath();
                ctx.fill();
            }

            ctx.stroke();

            points.forEach((point, index) => {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                ctx.fill();

                if (isDrawing) {
                    ctx.fillStyle = '#000';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(index + 1, point.x, point.y - 10);
                }
            });

            if (points.length > 0 && label && !isDrawing) {
                const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, centerX, centerY + 5);

                ctx.fillStyle = '#FFF';
                ctx.fillText(label, centerX - 1, centerY + 4);
            }

            ctx.restore();
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        async function startWebcam(cameraId) {
            console.log(`Starting webcam for camera ${cameraId}`);

            updateCameraState(cameraId, {
                isReady: false,
                videoWidth: null,
                videoHeight: null
            });

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 }
                });

                const video = document.getElementById('webcamVideo');
                currentStream = stream;
                video.srcObject = stream;

                video.onloadedmetadata = () => {
                    console.log('Webcam metadata loaded');

                    video.oncanplay = () => {
                        console.log('Webcam can play - updating state');

                        updateCameraState(cameraId, {
                            video: video,
                            videoWidth: video.videoWidth || 1280,
                            videoHeight: video.videoHeight || 720
                        });

                        video.style.display = 'block';
                        document.getElementById(`cameraPlaceholder${cameraId}`).style.display = 'none';

                        document.getElementById('startWebcam1').disabled = true;
                        document.getElementById('stopWebcam1').disabled = false;

                        setTimeout(() => {
                            updateCanvasSize(cameraId);

                            setTimeout(() => {
                                loadSavedZones(cameraId).then(() => {
                                    showMessage('Camera started successfully', 'success');
                                });
                            }, 100);
                        }, 200);
                    };

                    if (video.readyState >= 3) {
                        video.oncanplay();
                    }
                };

            } catch (error) {
                console.error('Error accessing webcam:', error);
                updateCameraState(cameraId, { isReady: false });
                showMessage('Error accessing camera. Please check permissions.', 'error');
            }
        }
        function stopWebcam(cameraId) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }

            const video = cameras[cameraId].video;
            if (video) {
                video.srcObject = null;
                video.style.display = 'none';
            }

            document.getElementById(`cameraPlaceholder${cameraId}`).style.display = 'block';

            if (cameraId === 1) {
                document.getElementById('startWebcam1').disabled = false;
                document.getElementById('stopWebcam1').disabled = true;
            }
            document.getElementById(`drawZoneBtn${cameraId}`).disabled = true;

            cameras[cameraId].isDrawing = false;
            cameras[cameraId].currentPath = [];
            updateDrawingMode(cameraId);
            redrawCanvas(cameraId);

            showMessage('Camera stopped', 'info');
        }

        function showVideoControls(visible) {
            const controls = document.getElementById('videoControls2');
            if (!controls) return;

            if (visible && cameras[2].videoLoaded) {
                controls.style.display = 'flex';
                controls.classList.add('visible');
                cameras[2].controlsVisible = true;
            } else {
                controls.style.display = 'none';
                controls.classList.remove('visible');
                cameras[2].controlsVisible = false;
            }
        }

        function setupVideoControls() {
            console.log('Setting up video controls...');

            const video = document.getElementById('recordedVideo');
            const playPauseBtn = document.getElementById('playPauseBtn2');
            const videoTime = document.getElementById('videoTime2');
            const videoScrubber = document.getElementById('videoScrubber2');
            const videoProgress = document.getElementById('videoProgress2');
            const volumeIcon = document.getElementById('volumeIcon2');
            const volumeSlider = document.getElementById('volumeSlider2');
            const volumeLevel = document.getElementById('volumeLevel2');

            if (!video || !playPauseBtn) {
                console.error('Video controls elements not found');
                return;
            }

            cameras[2].video = video;
            video.volume = 0.5;
            if (volumeLevel) volumeLevel.style.width = '50%';

            playPauseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                console.log('Play/Pause clicked, video paused:', video.paused);

                if (video.paused) {
                    const playPromise = video.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Video playing');
                            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                        }).catch(e => {
                            console.error('Error playing video:', e);
                            showMessage('Error playing video', 'error');
                        });
                    }
                } else {
                    video.pause();
                    console.log('Video paused');
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                }
            });

            if (volumeSlider) {
                volumeSlider.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const rect = volumeSlider.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const percentage = Math.max(0, Math.min(1, clickX / rect.width));
                    video.volume = percentage;
                    if (volumeLevel) volumeLevel.style.width = `${percentage * 100}%`;
                    updateVolumeIcon();
                });
            }

            if (volumeIcon) {
                volumeIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    if (video.volume > 0) {
                        video.dataset.previousVolume = video.volume;
                        video.volume = 0;
                        if (volumeLevel) volumeLevel.style.width = '0%';
                    } else {
                        video.volume = video.dataset.previousVolume || 0.5;
                        if (volumeLevel) volumeLevel.style.width = `${video.volume * 100}%`;
                    }
                    updateVolumeIcon();
                });
            }

            function updateVolumeIcon() {
                if (!volumeIcon) return;

                if (video.volume === 0) {
                    volumeIcon.className = 'fas fa-volume-mute volume-icon';
                } else if (video.volume < 0.5) {
                    volumeIcon.className = 'fas fa-volume-down volume-icon';
                } else {
                    volumeIcon.className = 'fas fa-volume-up volume-icon';
                }
            }

            video.addEventListener('timeupdate', () => {
                if (video.duration && !isNaN(video.duration) && isFinite(video.duration)) {
                    const currentTime = formatTime(video.currentTime);
                    const duration = formatTime(video.duration);
                    if (videoTime) videoTime.textContent = `${currentTime} / ${duration}`;

                    const progress = (video.currentTime / video.duration) * 100;
                    if (videoProgress) videoProgress.style.width = `${progress}%`;
                }
            });

            video.addEventListener('ended', () => {
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
            });

            let isDragging = false;

            if (videoScrubber) {
                videoScrubber.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    updateVideoTime(e);
                });

                videoScrubber.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isDragging) {
                        updateVideoTime(e);
                    }
                });

                function updateVideoTime(e) {
                    if (video.duration && !isNaN(video.duration) && isFinite(video.duration)) {
                        const rect = videoScrubber.getBoundingClientRect();
                        const clickX = e.clientX - rect.left;
                        const percentage = Math.max(0, Math.min(1, clickX / rect.width));
                        video.currentTime = percentage * video.duration;
                        console.log('Video time updated to:', video.currentTime);
                    }
                }

                document.addEventListener('mousemove', (e) => {
                    if (isDragging && video.duration && !isNaN(video.duration) && isFinite(video.duration)) {
                        updateVideoTime(e);
                    }
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }

            video.addEventListener('loadstart', () => {
                console.log('Video loading started');
            });

            video.addEventListener('loadedmetadata', () => {
                console.log('Video metadata loaded, duration:', video.duration);
                if (video.duration && !isNaN(video.duration) && isFinite(video.duration)) {
                    const duration = formatTime(video.duration);
                    if (videoTime) videoTime.textContent = `00:00 / ${duration}`;
                    playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';

                    setTimeout(() => updateCanvasSize(2), 100);

                    cameras[2].videoLoaded = true;
                    setTimeout(() => {
                        if (!cameras[2].isDrawing) {
                            showVideoControls(true);
                        }
                    }, 200);
                } else {
                    console.error('Invalid video duration:', video.duration);
                }
            });

            video.addEventListener('loadeddata', () => {
                console.log('Video data loaded');
            });

            video.addEventListener('canplay', () => {
                console.log('Video can play');
            });

            video.addEventListener('canplaythrough', () => {
                console.log('Video can play through');
            });

            video.addEventListener('error', (e) => {
                console.error('Video error:', e);
                showMessage('Error loading video', 'error');
                cameras[2].videoLoaded = false;
                showVideoControls(false);
            });

            const videoContainer = video.parentElement;
            let controlsHoverTimeout;

            if (videoContainer) {
                videoContainer.addEventListener('mouseenter', () => {
                    clearTimeout(controlsHoverTimeout);
                    if (cameras[2].videoLoaded && !cameras[2].isDrawing) {
                        showVideoControls(true);
                    }
                });

                videoContainer.addEventListener('mouseleave', () => {
                    controlsHoverTimeout = setTimeout(() => {
                        if (cameras[2].videoLoaded && !cameras[2].isDrawing && video.paused) {
                            const controls = document.getElementById('videoControls2');
                            if (controls) {
                                controls.style.opacity = '0.7';
                            }
                        }
                    }, 2000);
                });

                video.addEventListener('click', (e) => {
                    if (!cameras[2].isDrawing) {
                        e.preventDefault();
                        e.stopPropagation();
                        showVideoControls(true);

                        if (video.paused) {
                            video.play().then(() => {
                                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
                            }).catch(console.error);
                        } else {
                            video.pause();
                            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
                        }
                    }
                });
            }

            console.log('Video controls setup completed');
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds) || seconds < 0) return '00:00';

            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = Math.floor(seconds % 60);

            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            }
        }

        async function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (file) {
                await handleVideoFile(file);
            }
        }

        async function handleVideoFile(file) {
            if (!file.type.startsWith('video/')) {
                showMessage('Please select a video file', 'error');
                return;
            }

            if (file.size > 500 * 1024 * 1024) {
                showMessage('File size too large. Maximum 500MB allowed.', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('video', file);

            try {
                showMessage('Uploading video...', 'info');

                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE}/upload-video`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                if (response.ok) {
                    const result = await response.json();
                    showMessage('Video uploaded successfully!', 'success');
                    loadUploadedVideos();
                    selectVideo(result.video.id, result.video.original_name, result.video.filename);
                } else {
                    const error = await response.json();
                    showMessage(`Upload failed: ${error.error}`, 'error');
                }
            } catch (error) {
                console.error('Upload error:', error);
                showMessage('Upload failed. Please try again.', 'error');
            }
        }

        async function loadUploadedVideos() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE}/videos`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const videos = await response.json();
                    displayUploadedVideos(videos);
                }
            } catch (error) {
                console.error('Error loading videos:', error);
            }
        }

        function displayUploadedVideos(videos) {
            const videoList = document.getElementById('videoList2');

            if (videos.length === 0) {
                videoList.innerHTML = '<p style="text-align: center; opacity: 0.7;">No videos uploaded yet</p>';
                return;
            }

            videoList.innerHTML = videos.map(video => `
                <div class="video-item" onclick="selectVideo(${video.id}, '${video.original_name}', '${video.filename}')" data-video-id="${video.id}">
                    <div>
                        <div style="font-weight: 600;">${video.original_name}</div>
                        <small>${(video.size / (1024 * 1024)).toFixed(1)} MB</small>
                    </div>
                    <i class="fas fa-play-circle"></i>
                </div>
            `).join('');
        }

        async function selectVideo(videoId, videoName, filename) {
            try {
                console.log('Selecting video:', { videoId, videoName, filename });

                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE}/set-current-video`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ videoId })
                });

                if (response.ok) {
                    selectedVideoId = videoId;
                    selectedVideoPath = filename;

                    document.querySelectorAll('.video-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    const selectedItem = document.querySelector(`[data-video-id="${videoId}"]`);
                    if (selectedItem) selectedItem.classList.add('selected');

                    await loadVideoPreview(filename, videoName);

                } else {
                    const error = await response.json();
                    showMessage(`Error selecting video: ${error.error}`, 'error');
                }
            } catch (error) {
                console.error('Error selecting video:', error);
                showMessage('Error selecting video', 'error');
            }
        }

        async function loadVideoPreview(filename, videoName) {
            const video = document.getElementById('recordedVideo');
            const placeholder = document.getElementById('cameraPlaceholder2');


            updateCameraState(2, {
                videoLoaded: false,
                isReady: false,
                videoWidth: null,
                videoHeight: null
            });

            showVideoControls(false);

            return new Promise((resolve, reject) => {
                const possibleUrls = [
                    `/api/video/${selectedVideoId}`,
                    `/uploads/${filename}`,
                    `${API_BASE}/video/${selectedVideoId}`
                ];

                let urlIndex = 0;

                const tryNextUrl = () => {
                    if (urlIndex >= possibleUrls.length) {
                        reject(new Error('All video URL formats failed'));
                        return;
                    }

                    const videoUrl = possibleUrls[urlIndex];
                    console.log(`Trying video URL:`, videoUrl);

                    video.onloadedmetadata = () => {
                        console.log('Video metadata loaded');


                        video.oncanplay = () => {
                            console.log('Video can play - updating state');


                            updateCameraState(2, {
                                video: video,
                                videoWidth: video.videoWidth,
                                videoHeight: video.videoHeight,
                                videoLoaded: true
                            });


                            video.style.display = 'block';
                            placeholder.style.display = 'none';
                            document.getElementById('videoPreview2').style.display = 'block';


                            setTimeout(() => {
                                updateCanvasSize(2);


                                setTimeout(() => {
                                    loadSavedZones(2).then(() => {
                                        showVideoControls(true);
                                        showMessage(`Video loaded: ${video.videoWidth}x${video.videoHeight}`, 'success');
                                        resolve();
                                    });
                                }, 100);
                            }, 200);
                        };


                        if (video.readyState >= 3) {
                            video.oncanplay();
                        }
                    };

                    video.onerror = () => {
                        urlIndex++;
                        if (urlIndex < possibleUrls.length) {
                            setTimeout(tryNextUrl, 1000);
                        } else {
                            updateCameraState(2, { videoLoaded: false });
                            reject(new Error('All video URLs failed'));
                        }
                    };

                    video.src = videoUrl;
                    video.load();
                };

                tryNextUrl();
            });
        }

        async function saveCurrentZone(cameraId) {
            const zoneName = document.getElementById(`zoneNameInput${cameraId}`).value.trim();
            const zoneCapacity = parseInt(document.getElementById(`zoneCapacityInput${cameraId}`).value);
            const zoneWarning = parseInt(document.getElementById(`zoneWarningInput${cameraId}`).value);

            if (!zoneName) {
                showMessage('Please enter a zone name', 'error');
                return;
            }

            if (!zoneCapacity || zoneCapacity <= 0) {
                showMessage('Please enter a valid capacity limit (greater than 0)', 'error');
                return;
            }

            if (!zoneWarning || zoneWarning <= 0) {
                showMessage('Please enter a valid warning threshold (greater than 0)', 'error');
                return;
            }

            if (zoneWarning >= zoneCapacity) {
                showMessage('Warning threshold should be less than capacity limit', 'error');
                return;
            }

            if (cameras[cameraId].currentPath.length < 3) {
                showMessage('Zone must have at least 3 points', 'error');
                return;
            }

            try {
                const token = localStorage.getItem('token');
                const user = JSON.parse(localStorage.getItem('user') || '{}');

                const zoneData = {
                    name: zoneName,
                    coordinates: JSON.stringify(cameras[cameraId].currentPath),
                    camera_id: cameraId,
                    user_id: user.id,
                    capacity_limit: zoneCapacity,
                    warning_threshold: zoneWarning,
                    alert_color: '#4ecdc4',
                    video_width: cameras[cameraId].videoWidth,
                    video_height: cameras[cameraId].videoHeight,
                    canvas_width: cameras[cameraId].canvasWidth,
                    canvas_height: cameras[cameraId].canvasHeight
                };
                const response = await fetch(`${API_BASE}/zones`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(zoneData)
                });

                if (response.ok) {
                    cameras[cameraId].currentPath = [];
                    document.getElementById(`zoneNameInput${cameraId}`).value = '';
                    document.getElementById(`zoneCapacityInput${cameraId}`).value = '10';
                    document.getElementById(`zoneWarningInput${cameraId}`).value = '8';
                    document.getElementById(`zoneNameGroup${cameraId}`).style.display = 'none';
                    document.getElementById(`zoneInstructions${cameraId}`).style.display = 'block';

                    loadSavedZones(cameraId);
                    redrawCanvas(cameraId);

                    showMessage(`Zone "${zoneName}" saved with capacity ${zoneCapacity}!`, 'success');

                    if (socket) {
                        socket.emit('update_zones', {
                            cameraId: cameraId,
                            zones: cameras[cameraId].savedZones
                        });
                    }
                } else {
                    const error = await response.json();
                    showMessage(`Error saving zone: ${error.error}`, 'error');
                }
            } catch (error) {
                console.error('Error saving zone:', error);
                showMessage('Error saving zone', 'error');
            }
        }
        function cancelCurrentZone(cameraId) {
            cameras[cameraId].currentPath = [];
            document.getElementById(`zoneNameInput${cameraId}`).value = '';
            document.getElementById(`zoneCapacityInput${cameraId}`).value = '10';
            document.getElementById(`zoneWarningInput${cameraId}`).value = '8';
            document.getElementById(`zoneNameGroup${cameraId}`).style.display = 'none';
            document.getElementById(`zoneInstructions${cameraId}`).style.display = 'block';

            redrawCanvas(cameraId);

            if (cameraId === 2 && cameras[2].videoLoaded) {
                setTimeout(() => showVideoControls(true), 100);
            }
        }
        async function loadSavedZones(cameraId) {
            console.log(`Loading zones for camera ${cameraId}...`);

            updateCameraState(cameraId, { zonesLoaded: false });

            try {
                const token = localStorage.getItem('token');

                const response = await fetch(`${API_BASE}/zones?camera_id=${cameraId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                console.log(`Loading zones for camera ${cameraId}, response status: ${response.status}`);

                if (response.ok) {
                    const dbZones = await response.json();
                    console.log(`Raw API response for camera ${cameraId}:`, dbZones);
                    console.log(`Loaded ${dbZones.length} zones from database for camera ${cameraId}`);

                    const zonesArray = Array.isArray(dbZones) ? dbZones : [];

                    const mappedZones = zonesArray.map((zone, index) => {

                        let coordinates = [];
                        try {
                            if (typeof zone.coordinates === 'string') {
                                coordinates = JSON.parse(zone.coordinates);
                            } else if (Array.isArray(zone.coordinates)) {
                                coordinates = zone.coordinates;
                            }
                        } catch (e) {
                            console.error(`Error parsing coordinates for zone ${zone.id}:`, e);
                            coordinates = [];
                        }

                        return {
                            id: zone.id,
                            name: zone.name,
                            points: coordinates,
                            color: zoneColors[index % zoneColors.length],
                            created: zone.created_at,
                            capacity_limit: zone.capacity_limit || 10,
                            warning_threshold: zone.warning_threshold || 8
                        };
                    });

                    console.log(`Mapped zones for camera ${cameraId}:`, mappedZones);


                    updateCameraState(cameraId, {
                        savedZones: mappedZones,
                        zonesLoaded: true
                    });


                    updateZonesList(cameraId);
                    redrawCanvas(cameraId);

                    console.log(`Zones loaded and state updated for camera ${cameraId}. Total zones: ${mappedZones.length}`);

                } else {
                    console.error('Failed to load zones:', response.status);
                    updateCameraState(cameraId, {
                        savedZones: [],
                        zonesLoaded: true
                    });
                }

            } catch (error) {
                console.error('Error loading saved zones:', error);
                updateCameraState(cameraId, {
                    savedZones: [],
                    zonesLoaded: true
                });
            }
        }
        function updateZonesList(cameraId) {
            const zonesList = document.getElementById(`zonesList${cameraId}`);

            if (cameras[cameraId].savedZones.length === 0) {
                zonesList.innerHTML = '<p style="opacity: 0.7; text-align: center;">No zones created yet</p>';
                return;
            }

            zonesList.innerHTML = cameras[cameraId].savedZones.map(zone => `
                <div class="zone-item">
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <div class="zone-color" style="background: ${zone.color};"></div>
                        <span>${zone.name}</span>
                    </div>
                    <button class="btn btn-danger btn-small" onclick="deleteZone(${cameraId}, ${zone.id})" style="padding: 0.25rem 0.5rem;">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `).join('');
        }

        async function deleteZone(cameraId, zoneId) {
            if (!confirm('Are you sure you want to delete this zone?')) return;

            try {
                const token = localStorage.getItem('token');

                const response = await fetch(`${API_BASE}/zones/${zoneId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    loadSavedZones(cameraId);
                    showMessage('Zone deleted successfully', 'info');

                    if (socket) {
                        socket.emit('update_zones', {
                            cameraId: cameraId,
                            zones: cameras[cameraId].savedZones.filter(z => z.id !== zoneId)
                        });
                    }
                } else {
                    const error = await response.json();
                    showMessage(`Error deleting zone: ${error.error}`, 'error');
                }
            } catch (error) {
                console.error('Error deleting zone:', error);
                showMessage('Error deleting zone', 'error');
            }
        }

        async function startYOLOProcessing(cameraId) {
            if (cameras[cameraId].savedZones.length === 0) {
                showMessage('Please create at least one zone before starting YOLO processing', 'error');
                return;
            }

            if (cameraId === 2 && !cameras[2].videoLoaded) {
                showMessage('Please select and load a video file before starting processing', 'error');
                return;
            }

            try {
                const token = localStorage.getItem('token');
                const requestData = {
                    cameraId: cameraId,
                    cameraType: cameraId === 1 ? 'live' : 'video',
                    cameraIndex: cameraId === 1 ? 0 : undefined
                };

                const startBtn = document.getElementById(`startProcessing${cameraId}`);
                const originalText = startBtn.innerHTML;
                startBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Starting...';
                startBtn.disabled = true;

                const response = await fetch(`${API_BASE}/start-yolo`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                const result = await response.json();

                if (response.ok) {
                    cameras[cameraId].processing = true;
                    updateProcessingButtons(cameraId, true);
                    showMessage(`YOLO processing started for Camera ${cameraId}`, 'success');

                    const yoloStatus = document.getElementById(`yoloStatus${cameraId}`);
                    if (yoloStatus) {
                        yoloStatus.classList.add('waiting');
                        yoloStatus.innerHTML = '<i class="fas fa-cog fa-spin"></i> YOLO Initializing...';
                    }
                } else {
                    startBtn.innerHTML = originalText;
                    startBtn.disabled = false;
                    showMessage(`Failed to start YOLO: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Error starting YOLO:', error);
                showMessage('Error starting YOLO processing', 'error');

                const startBtn = document.getElementById(`startProcessing${cameraId}`);
                startBtn.innerHTML = '<i class="fas fa-brain"></i> Start YOLO';
                startBtn.disabled = false;
            }
        }

        async function stopYOLOProcessing(cameraId) {
            try {
                const token = localStorage.getItem('token');

                const stopBtn = document.getElementById(`stopProcessing${cameraId}`);
                const originalText = stopBtn.innerHTML;
                stopBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Stopping...';
                stopBtn.disabled = true;

                const response = await fetch(`${API_BASE}/stop-yolo`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ cameraId })
                });

                const result = await response.json();

                if (response.ok) {
                    cameras[cameraId].processing = false;
                    cameras[cameraId].yoloActive = false;
                    updateProcessingButtons(cameraId, false);
                    showMessage(`YOLO processing stopped for Camera ${cameraId}`, 'info');

                    const indicatorEl = document.getElementById(`camera${cameraId}Indicator`);
                    const yoloStatusEl = document.getElementById(`yoloStatus${cameraId}`);
                    if (indicatorEl) indicatorEl.classList.remove('active');
                    if (yoloStatusEl) {
                        yoloStatusEl.classList.remove('active', 'waiting');
                    }
                } else {
                    stopBtn.innerHTML = originalText;
                    stopBtn.disabled = true;
                    showMessage(`Failed to stop YOLO: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Error stopping YOLO:', error);
                showMessage('Error stopping YOLO processing', 'error');

                const stopBtn = document.getElementById(`stopProcessing${cameraId}`);
                stopBtn.innerHTML = '<i class="fas fa-stop"></i> Stop YOLO';
                stopBtn.disabled = true;
            }
        }

        function updateLiveStats(data) {
            console.log('Updating live stats:', data);

            if (data.camera_id === 1) {
                updateCamera1Stats(data);
            } else if (data.camera_id === 2) {
                updateCamera2Stats(data);
            }
        }
        function updateCamera1Stats(data) {

            console.log('Camera 1 Live Stats:', data);
            if (data.total_count !== undefined) {
                const camera1Container = document.querySelector('#camera1Modal .video-container');
                if (camera1Container) {
                    let statsOverlay = camera1Container.querySelector('.live-stats-overlay');
                    if (!statsOverlay) {
                        statsOverlay = document.createElement('div');
                        statsOverlay.className = 'live-stats-overlay';
                        statsOverlay.style.cssText = `
                    position: absolute;
                    top: 60px;
                    left: 15px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 0.5rem 1rem;
                    border-radius: 10px;
                    font-size: 0.9rem;
                    z-index: 25;
                `;
                        camera1Container.appendChild(statsOverlay);
                    }

                    let statsHTML = `<strong>Live Count: ${data.total_count || 0}</strong>`;
                    if (data.zone_counts && Object.keys(data.zone_counts).length > 0) {
                        statsHTML += '<br><small>';
                        for (const [zoneName, count] of Object.entries(data.zone_counts)) {
                            statsHTML += `${zoneName}: ${count} `;
                        }
                        statsHTML += '</small>';
                    }

                    statsOverlay.innerHTML = statsHTML;
                }
            }
        }

        function updateCamera2Stats(data) {
            const totalCountElement = document.getElementById('totalCount2');
            const zoneStatsElement = document.getElementById('zoneStats2');

            if (!totalCountElement || !zoneStatsElement) {
                console.warn('Camera 2 stats elements not found');
                return;
            }

            console.log('Updating Camera 2 stats:', data);
            const currentTotal = parseInt(totalCountElement.textContent) || 0;
            const newTotal = data.total_count || 0;

            if (currentTotal !== newTotal) {
                totalCountElement.textContent = newTotal;
                totalCountElement.classList.add('updated');
                setTimeout(() => totalCountElement.classList.remove('updated'), 500);
            }
            if (data.zone_counts && Object.keys(data.zone_counts).length > 0) {
                let zoneStatsHTML = '';
                for (const [zoneName, count] of Object.entries(data.zone_counts)) {
                    // Handle both named zones and 'z' prefixed zones from your output
                    const displayName = zoneName.startsWith('z') ? `Zone ${zoneName.substring(1)}` : zoneName;
                    const zone = cameras[2].savedZones.find(z => z.name === zoneName || z.name === displayName);
                    const color = zone ? zone.color : '#4ecdc4';

                    zoneStatsHTML += `
                <div style="display: flex; justify-content: space-between; align-items: center; 
                           padding: 0.5rem; margin-bottom: 0.25rem; background: rgba(255, 255, 255, 0.1); 
                           border-radius: 8px; border-left: 4px solid ${color}; transition: all 0.3s ease;">
                    <span style="font-weight: 500;">${displayName}</span>
                    <span style="font-weight: 600; color: ${color}; font-size: 1.1rem;">${count}</span>
                </div>
            `;
                }
                zoneStatsElement.innerHTML = zoneStatsHTML;
            } else if (cameras[2].yoloActive) {
                zoneStatsElement.innerHTML = '<p style="opacity: 0.7; text-align: center; font-style: italic;">No detections in zones</p>';
            } else {
                zoneStatsElement.innerHTML = '<p style="opacity: 0.7; text-align: center; font-style: italic;">Start YOLO processing to see live counts</p>';
            }
            if (data.fps) {
                const fpsElement = zoneStatsElement.parentElement.querySelector('.fps-display');
                if (!fpsElement) {
                    const fpsDiv = document.createElement('div');
                    fpsDiv.className = 'fps-display';
                    fpsDiv.style.cssText = `
                text-align: center; 
                margin-top: 0.5rem; 
                padding: 0.25rem; 
                background: rgba(255, 255, 255, 0.05); 
                border-radius: 5px; 
                font-size: 0.8rem; 
                opacity: 0.8;
            `;
                    zoneStatsElement.parentElement.appendChild(fpsDiv);
                }
                zoneStatsElement.parentElement.querySelector('.fps-display').textContent = `FPS: ${data.fps.toFixed(1)}`;
            }
        }
        function handleProcessingStatus(status) {
            const { cameraId, status: statusType, message } = status;

            if (statusType === 'started') {
                cameras[cameraId].processing = true;
                updateProcessingButtons(cameraId, true);
                showMessage(`Camera ${cameraId} processing started`, 'success');
            } else if (statusType === 'stopped') {
                cameras[cameraId].processing = false;
                cameras[cameraId].yoloActive = false;
                updateProcessingButtons(cameraId, false);
                showMessage(`Camera ${cameraId} processing stopped`, 'info');

                const indicatorEl = document.getElementById(`camera${cameraId}Indicator`);
                const yoloStatusEl = document.getElementById(`yoloStatus${cameraId}`);
                if (indicatorEl) indicatorEl.classList.remove('active');
                if (yoloStatusEl) {
                    yoloStatusEl.classList.remove('active', 'waiting');
                }
            } else if (statusType === 'error') {
                cameras[cameraId].processing = false;
                cameras[cameraId].yoloActive = false;
                updateProcessingButtons(cameraId, false);
                showMessage(message, 'error');
            }
        }

        function updateProcessingButtonsWithState(cameraId, readiness) {
            const startBtn = document.getElementById(`startProcessing${cameraId}`);
            const stopBtn = document.getElementById(`stopProcessing${cameraId}`);

            if (!startBtn || !stopBtn) {
                console.warn(`Processing buttons not found for camera ${cameraId}`);
                return;
            }

            const isProcessing = cameras[cameraId].processing;

            if (isProcessing) {
                startBtn.disabled = true;
                startBtn.innerHTML = '<i class="fas fa-brain"></i> YOLO Running';
                stopBtn.disabled = false;
                stopBtn.innerHTML = '<i class="fas fa-stop"></i> Stop YOLO';
            } else {
                const canStart = readiness.isFullyReady && readiness.hasZones;

                startBtn.disabled = !canStart;
                stopBtn.disabled = true;

                if (canStart) {
                    startBtn.innerHTML = '<i class="fas fa-brain"></i> Start YOLO';
                    startBtn.title = 'Ready to start YOLO processing';
                } else {
                    startBtn.innerHTML = '<i class="fas fa-brain"></i> Start YOLO';
                    if (!readiness.videoReady) {
                        startBtn.title = `Camera ${cameraId === 1 ? 'not started' : 'video not loaded'}`;
                    } else if (!readiness.hasZones) {
                        startBtn.title = 'No zones created yet';
                    } else if (!readiness.zonesLoaded) {
                        startBtn.title = 'Zones still loading...';
                    } else if (!readiness.hasValidDimensions) {
                        startBtn.title = 'Video dimensions not available';
                    } else {
                        startBtn.title = 'Camera not ready';
                    }
                }

                stopBtn.innerHTML = '<i class="fas fa-stop"></i> Stop YOLO';
            }

            console.log(`Buttons updated for camera ${cameraId}: Start disabled=${startBtn.disabled}, Stop disabled=${stopBtn.disabled}`);
        }

        function updateProcessingButtons(cameraId, isProcessing) {
            const readiness = checkCameraReadiness(cameraId);
            updateProcessingButtonsWithState(cameraId, readiness);
        }

        async function checkYOLORequirements() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_BASE}/check-yolo-requirements`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                const result = await response.json();

                if (!result.python || !result.requirements) {
                    let message = 'YOLO Requirements Check:\n\n';

                    if (!result.python) {
                        message += ' Python not found\n';
                        message += `${result.suggestion || 'Please install Python 3.7+'}\n\n`;
                    } else {
                        message += ` Python found: ${result.pythonVersion}\n\n`;
                    }

                    if (!result.requirements) {
                        message += ' Missing required packages:\n';
                        if (result.missingPackages) {
                            message += ` ${result.missingPackages.join('\n ')}\n\n`;
                            message += `Install with: ${result.installCommand}\n\n`;
                        }
                    } else {
                        message += ' All required packages available\n\n';
                    }

                    if (!result.python || !result.requirements) {
                        showMessage('YOLO requirements not met. Check console for details.', 'error');
                        console.log(message);
                        return false;
                    }
                }

                return true;
            } catch (error) {
                console.error('Error checking YOLO requirements:', error);
                showMessage('Could not check YOLO requirements', 'error');
                return false;
            }
        }

        async function getYOLOStatus(cameraId = null) {
            try {
                const token = localStorage.getItem('token');
                const url = cameraId ?
                    `${API_BASE}/yolo-status?cameraId=${cameraId}` :
                    `${API_BASE}/yolo-status`;

                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.error('Error getting YOLO status:', error);
            }

            return null;
        }

        async function monitorYOLOProcesses() {
            const status1 = await getYOLOStatus(1);
            const status2 = await getYOLOStatus(2);

            if (status1) {
                updateCameraYOLOStatus(1, status1);
            }

            if (status2) {
                updateCameraYOLOStatus(2, status2);
            }
        }

        function updateCameraYOLOStatus(cameraId, statusData) {
            const { status, message } = statusData;
            const indicatorEl = document.getElementById(`camera${cameraId}Indicator`);
            const yoloStatusEl = document.getElementById(`yoloStatus${cameraId}`);

            cameras[cameraId].processing = ['starting', 'initializing', 'running'].includes(status);
            cameras[cameraId].yoloActive = status === 'running';

            updateProcessingButtons(cameraId, cameras[cameraId].processing);

            if (indicatorEl) {
                if (status === 'running') {
                    indicatorEl.classList.add('active');
                } else {
                    indicatorEl.classList.remove('active');
                }
            }

            if (yoloStatusEl) {
                yoloStatusEl.classList.remove('active', 'waiting');

                switch (status) {
                    case 'running':
                        yoloStatusEl.classList.add('active');
                        yoloStatusEl.innerHTML = '<i class="fas fa-brain"></i> YOLO Processing Active';
                        break;
                    case 'starting':
                    case 'initializing':
                        yoloStatusEl.classList.add('waiting');
                        yoloStatusEl.innerHTML = '<i class="fas fa-cog fa-spin"></i> YOLO Starting...';
                        break;
                    case 'stopping':
                        yoloStatusEl.classList.add('waiting');
                        yoloStatusEl.innerHTML = '<i class="fas fa-stop"></i> YOLO Stopping...';
                        break;
                    case 'error':
                        yoloStatusEl.innerHTML = '<i class="fas fa-exclamation-triangle"></i> YOLO Error';
                        break;
                    default:
                        break;
                }
            }
        }

        setInterval(() => {
            if (socket && socket.connected) {
                monitorYOLOProcesses();
            }
        }, 10000);

        function showMessage(message, type = 'info') {
            const existing = document.querySelector('.message');
            if (existing) existing.remove();

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;

            let icon = '';
            switch (type) {
                case 'success': icon = '<i class="fas fa-check-circle"></i>'; break;
                case 'error': icon = '<i class="fas fa-exclamation-triangle"></i>'; break;
                case 'info': default: icon = '<i class="fas fa-info-circle"></i>'; break;
            }

            messageDiv.innerHTML = `${icon} ${message}`;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                if (messageDiv.parentNode) messageDiv.remove();
            }, 5000);
        }

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                stopYOLOProcessing(1);
                stopYOLOProcessing(2);
                stopWebcam(1);

                localStorage.removeItem('token');
                localStorage.removeItem('user');
                window.location.href = '/';
            }
        }

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const modal1 = document.getElementById('camera1Modal');
                const modal2 = document.getElementById('camera2Modal');

                if (modal1.style.display === 'block') {
                    closeCameraModal(1);
                } else if (modal2.style.display === 'block') {
                    closeCameraModal(2);
                }
            }

            if (event.key === 'Enter') {
                const activeElement = document.activeElement;
                if (activeElement.id === 'zoneNameInput1') {
                    saveCurrentZone(1);
                } else if (activeElement.id === 'zoneNameInput2') {
                    saveCurrentZone(2);
                }
            }
        });

        window.addEventListener('beforeunload', () => {
            stopWebcam(1);
            stopYOLOProcessing(1);
            stopYOLOProcessing(2);
        });

        function validateAndSyncStates() {
            [1, 2].forEach(cameraId => {
                const readiness = checkCameraReadiness(cameraId);
                const currentReady = cameras[cameraId].isReady;


                if (readiness.isFullyReady !== currentReady) {
                    console.log(`Camera ${cameraId} readiness changed: ${currentReady} -> ${readiness.isFullyReady}`);
                    updateCameraState(cameraId, { isReady: readiness.isFullyReady });
                }
            });
        }


        setInterval(validateAndSyncStates, 3000);


        function debugCameraState(cameraId) {
            const camera = cameras[cameraId];
            const readiness = checkCameraReadiness(cameraId);

            console.log(`=== Camera ${cameraId} Debug State ===`);
            console.log('Camera object:', camera);
            console.log('Readiness check:', readiness);
            console.log('Video element:', camera.video);
            console.log('Video ready state:', camera.video ? camera.video.readyState : 'N/A');
            console.log('Video dimensions:', `${camera.videoWidth}x${camera.videoHeight}`);
            console.log('Canvas dimensions:', `${camera.canvasWidth}x${camera.canvasHeight}`);
            console.log('Saved zones count:', camera.savedZones ? camera.savedZones.length : 0);
            console.log('=====================================');
        }


        window.debugCameraState = debugCameraState;
    </script>
</body>

</html>